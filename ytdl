#!/bin/bash

# Interactive YouTube Downloader CLI
# A beautiful, user-friendly YouTube video downloader
# Author: Your Name
# Version: 1.0.0

set -e

# Colors for beautiful UI
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Configuration
DOWNLOADS_DIR="$HOME/Downloads/YouTube Videos"
TEMP_DIR="/tmp/ytdl_$$"

# Create necessary directories
mkdir -p "$DOWNLOADS_DIR"
mkdir -p "$TEMP_DIR"

# Cleanup function
cleanup() {
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# Function to print colored output with emojis
print_header() {
    echo -e "${PURPLE}${BOLD}$1${NC}"
}

print_info() {
    echo -e "${CYAN}$1${NC}"
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

print_error() {
    echo -e "${RED}$1${NC}"
}

print_dim() {
    echo -e "${GRAY}${DIM}$1${NC}"
}

# Function to draw a separator line
draw_separator() {
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Function to get username
get_username() {
    local username=""
    if [[ -n "$USER" ]]; then
        username="$USER"
    elif [[ -n "$LOGNAME" ]]; then
        username="$LOGNAME"
    elif command -v whoami &> /dev/null; then
        username=$(whoami)
    else
        username="User"
    fi
    echo "$username"
}

# Function to check dependencies
check_dependencies() {
    print_info "🔍 Checking system requirements..."
    echo
    
    # Check if we're on macOS
    if [[ "$OSTYPE" != "darwin"* ]]; then
        print_error "❌ This script currently supports macOS only."
        print_info "💡 Please ensure yt-dlp and ffmpeg are installed manually."
        echo
        exit 1
    fi
    
    print_info "💻 System: macOS"
    
    # Check for Homebrew
    local brew_installed=true
    if ! command -v brew &> /dev/null; then
        brew_installed=false
        print_warning "⚠️  Homebrew is not installed."
        print_info "📝 Homebrew is a package manager for macOS that makes installing software easy."
        echo
        
        if ask_install_permission "Homebrew"; then
            print_info "📦 Installing Homebrew..."
            print_dim "This may take a few minutes..."
            echo
            
            # Install Homebrew
            if /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
                print_success "✅ Homebrew installed successfully!"
                
                # Add Homebrew to PATH for current session
                if [[ -f "/opt/homebrew/bin/brew" ]]; then
                    export PATH="/opt/homebrew/bin:$PATH"
                elif [[ -f "/usr/local/bin/brew" ]]; then
                    export PATH="/usr/local/bin:$PATH"
                fi
                
                brew_installed=true
                echo
            else
                print_error "❌ Failed to install Homebrew"
                print_info "💡 Please install Homebrew manually and run this script again:"
                print_info "   /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                echo
                exit 1
            fi
        else
            print_error "❌ Homebrew is required for automatic package installation."
            print_info "💡 Please install Homebrew manually and run this script again:"
            print_info "   /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            echo
            exit 1
        fi
    else
        print_success "✅ Homebrew is installed"
    fi
    
    # Check required packages
    local missing_packages=()
    
    if ! command -v yt-dlp &> /dev/null; then
        missing_packages+=("yt-dlp")
    fi
    
    if ! command -v ffmpeg &> /dev/null; then
        missing_packages+=("ffmpeg")
    fi
    
    # Install missing packages if any
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        echo
        print_warning "⚠️  Missing required packages:"
        for package in "${missing_packages[@]}"; do
            print_warning "   • $package"
        done
        echo
        
        print_info "📝 These packages are required for the YouTube downloader to work:"
        print_info "   • yt-dlp: Core tool for downloading YouTube videos"
        print_info "   • ffmpeg: Required for merging video/audio and processing media"
        echo
        
        if ask_install_permission "the required packages (yt-dlp and ffmpeg)"; then
            print_info "📦 Installing required packages..."
            echo
            
            local install_success=true
            
            for package in "${missing_packages[@]}"; do
                print_info "🔄 Installing $package..."
                if brew install "$package"; then
                    print_success "✅ $package installed successfully!"
                else
                    print_error "❌ Failed to install $package"
                    install_success=false
                fi
                echo
            done
            
            if [[ "$install_success" == true ]]; then
                print_success "🎉 All required packages installed successfully!"
            else
                print_error "❌ Some packages failed to install. Please install them manually:"
                for package in "${missing_packages[@]}"; do
                    print_info "   brew install $package"
                done
                echo
                exit 1
            fi
        else
            print_error "❌ Required packages are needed for the app to work."
            print_info "💡 You can install them manually with:"
            for package in "${missing_packages[@]}"; do
                print_info "   brew install $package"
            done
            echo
            exit 1
        fi
    else
        print_success "✅ All required packages are installed"
    fi
    
    # Install jq quietly if not present (for JSON parsing)
    if ! command -v jq &> /dev/null; then
        print_info "📦 Installing jq (JSON processor)..."
        brew install jq >/dev/null 2>&1 || print_warning "⚠️  Could not install jq. Some features may be limited."
    fi
    
    echo
    draw_separator
    echo
}

# Function to ask user for installation permission
ask_install_permission() {
    local item="$1"
    
    while true; do
        echo -e "${CYAN}🤔 Would you like to install $item now? (y/n): ${NC}"
        read -n 1 -r answer
        echo
        
        case $answer in
            [Yy]*)
                return 0
                ;;
            [Nn]*)
                return 1
                ;;
            *)
                print_error "   ❌ Please answer y (yes) or n (no)."
                ;;
        esac
    done
}

# Function to validate YouTube URL
validate_url() {
    local url="$1"
    if [[ $url =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
        return 0
    else
        return 1
    fi
}

# Function to show welcome screen
show_welcome() {
    clear
    local username=$(get_username)
    
    echo
    print_header "🎬 ═══════════════════════════════════════════════════════════════"
    print_header "    INTERACTIVE YOUTUBE DOWNLOADER"
    print_header "═══════════════════════════════════════════════════════════════"
    echo
    print_info "    👋 Hi ${BOLD}${WHITE}$username${NC}${CYAN}! Welcome to Interactive YouTube Downloader"
    echo
    print_dim "    📁 Downloads will be saved to: $DOWNLOADS_DIR"
    print_dim "    🔧 Powered by yt-dlp and ffmpeg"
    echo
    draw_separator
    echo
}

# Function to get video information
get_video_info() {
    local url="$1"
    local info_file="$TEMP_DIR/video_info.json"
    
    print_info "🔍 Fetching video information..."
    echo
    
    # Get video information
    if ! yt-dlp --dump-json --no-download "$url" > "$info_file" 2>/dev/null; then
        print_error "❌ Failed to fetch video information"
        return 1
    fi
    
    # Parse video information
    local title=$(jq -r '.title // "Unknown"' "$info_file" 2>/dev/null || echo "Unknown")
    local uploader=$(jq -r '.uploader // "Unknown"' "$info_file" 2>/dev/null || echo "Unknown")
    local duration=$(jq -r '.duration_string // "Unknown"' "$info_file" 2>/dev/null || echo "Unknown")
    local view_count=$(jq -r '.view_count // 0' "$info_file" 2>/dev/null || echo "0")
    local upload_date=$(jq -r '.upload_date // "Unknown"' "$info_file" 2>/dev/null || echo "Unknown")
    
    # Format view count
    if [[ "$view_count" =~ ^[0-9]+$ ]] && [[ $view_count -gt 0 ]]; then
        if [[ $view_count -ge 1000000000 ]]; then
            view_count=$(echo "scale=1; $view_count/1000000000" | bc 2>/dev/null || echo "$view_count")B
        elif [[ $view_count -ge 1000000 ]]; then
            view_count=$(echo "scale=1; $view_count/1000000" | bc 2>/dev/null || echo "$view_count")M
        elif [[ $view_count -ge 1000 ]]; then
            view_count=$(echo "scale=1; $view_count/1000" | bc 2>/dev/null || echo "$view_count")K
        fi
        view_count="${view_count} views"
    else
        view_count="Unknown views"
    fi
    
    # Format upload date
    if [[ "$upload_date" =~ ^[0-9]{8}$ ]]; then
        upload_date="${upload_date:0:4}-${upload_date:4:2}-${upload_date:6:2}"
    fi
    
    # Display video information
    print_success "✅ Video information retrieved successfully!"
    echo
    echo -e "${WHITE}${BOLD}📹 Video Details:${NC}"
    draw_separator
    echo -e "${CYAN}   Title:${NC}     ${WHITE}$title${NC}"
    echo -e "${CYAN}   Channel:${NC}   ${WHITE}$uploader${NC}"
    echo -e "${CYAN}   Duration:${NC}  ${WHITE}$duration${NC}"
    echo -e "${CYAN}   Views:${NC}     ${WHITE}$view_count${NC}"
    echo -e "${CYAN}   Uploaded:${NC}  ${WHITE}$upload_date${NC}"
    draw_separator
    echo
}

# Function to get available formats
get_available_formats() {
    local url="$1"
    local formats_file="$TEMP_DIR/formats.txt"
    
    print_info "🔍 Analyzing available formats..."
    
    # Get format list
    yt-dlp -F "$url" 2>/dev/null > "$formats_file"
    
    # Parse video formats
    local video_formats=()
    local format_descriptions=()
    
    # Add audio-only option
    video_formats+=("bestaudio")
    format_descriptions+=("🎵 Audio Only (Best Quality)")
    
    # Parse available video formats
    while IFS= read -r line; do
        if [[ "$line" =~ ^[0-9]+ ]] && [[ "$line" =~ video ]] && [[ ! "$line" =~ "audio only" ]]; then
            local format_id=$(echo "$line" | awk '{print $1}')
            local ext=$(echo "$line" | awk '{print $2}')
            local resolution=$(echo "$line" | awk '{print $3}')
            local fps=$(echo "$line" | grep -o '[0-9]*fps' || echo "")
            local filesize=$(echo "$line" | grep -o '[0-9.]*[MG]iB' || echo "")
            
            # Determine quality emoji and label
            local quality_emoji=""
            local quality_label=""
            
            if [[ "$resolution" =~ "3840x2160" || "$resolution" =~ "2160" ]]; then
                quality_emoji="🏆"
                quality_label="4K UHD"
            elif [[ "$resolution" =~ "2560x1440" || "$resolution" =~ "1440" ]]; then
                quality_emoji="💎"
                quality_label="2K QHD"
            elif [[ "$resolution" =~ "1920x1080" || "$resolution" =~ "1080" ]]; then
                quality_emoji="⭐"
                quality_label="Full HD"
            elif [[ "$resolution" =~ "1280x720" || "$resolution" =~ "720" ]]; then
                quality_emoji="📺"
                quality_label="HD"
            elif [[ "$resolution" =~ "480" ]]; then
                quality_emoji="📱"
                quality_label="SD"
            else
                quality_emoji="📹"
                quality_label="$resolution"
            fi
            
            # Build description
            local description="$quality_emoji $quality_label"
            [[ -n "$resolution" ]] && description+=" ($resolution)"
            [[ -n "$ext" ]] && description+=" [$ext]"
            [[ -n "$fps" ]] && description+=" $fps"
            [[ -n "$filesize" ]] && description+=" - $filesize"
            
            video_formats+=("$format_id")
            format_descriptions+=("$description")
        fi
    done < "$formats_file"
    
    # Add best quality option
    video_formats+=("best")
    format_descriptions+=("🚀 Best Available (Auto-select)")
    
    # Store in global arrays
    AVAILABLE_FORMATS=("${video_formats[@]}")
    FORMAT_DESCRIPTIONS=("${format_descriptions[@]}")
}

# Function to show format options menu
show_format_menu() {
    echo
    print_header "📋 Available Download Options:"
    draw_separator
    
    for i in "${!FORMAT_DESCRIPTIONS[@]}"; do
        local num=$((i + 1))
        echo -e "${WHITE}   $num.${NC} ${FORMAT_DESCRIPTIONS[$i]}"
    done
    
    draw_separator
    echo
}

# Function to get user choice
get_user_choice() {
    local max_choice=${#AVAILABLE_FORMATS[@]}
    local choice=""
    
    while true; do
        echo -e "${CYAN}🎯 Select download option (1-$max_choice): ${NC}"
        read -r choice
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $max_choice ]]; then
            SELECTED_FORMAT_INDEX=$((choice - 1))
            break
        else
            print_error "   ❌ Invalid choice. Please enter a number between 1 and $max_choice."
            echo
        fi
    done
    
    echo
    print_success "✅ Selected: ${FORMAT_DESCRIPTIONS[$SELECTED_FORMAT_INDEX]}"
    echo
}

# Function to check available subtitles
check_subtitles() {
    local url="$1"
    local subs_file="$TEMP_DIR/subtitles.txt"
    
    print_info "🔍 Checking available subtitles..."
    
    # Get subtitle information
    yt-dlp --list-subs "$url" 2>/dev/null > "$subs_file" || return 1
    
    # Check if subtitles are available
    if grep -q "Available subtitles" "$subs_file"; then
        # Parse available subtitle languages
        local available_subs=()
        while IFS= read -r line; do
            if [[ "$line" =~ ^[a-z]{2}(-[A-Z]{2})? ]]; then
                local lang_code=$(echo "$line" | awk '{print $1}')
                local lang_name=$(echo "$line" | cut -d' ' -f2- | sed 's/^[[:space:]]*//')
                available_subs+=("$lang_code|$lang_name")
            fi
        done < "$subs_file"
        
        if [[ ${#available_subs[@]} -gt 0 ]]; then
            AVAILABLE_SUBTITLES=("${available_subs[@]}")
            return 0
        fi
    fi
    
    return 1
}

# Function to show subtitle options
show_subtitle_options() {
    echo
    print_header "📝 Subtitle Options:"
    draw_separator
    
    echo -e "${WHITE}   1.${NC} 🚫 No subtitles"
    echo -e "${WHITE}   2.${NC} 🌍 Auto-select (English if available)"
    
    local counter=3
    for sub in "${AVAILABLE_SUBTITLES[@]}"; do
        local lang_code=$(echo "$sub" | cut -d'|' -f1)
        local lang_name=$(echo "$sub" | cut -d'|' -f2)
        echo -e "${WHITE}   $counter.${NC} 🔤 $lang_name ($lang_code)"
        ((counter++))
    done
    
    draw_separator
    echo
}

# Function to get subtitle choice
get_subtitle_choice() {
    local max_choice=$((2 + ${#AVAILABLE_SUBTITLES[@]}))
    local choice=""
    
    while true; do
        echo -e "${CYAN}📝 Select subtitle option (1-$max_choice): ${NC}"
        read -r choice
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $max_choice ]]; then
            SELECTED_SUBTITLE_INDEX=$choice
            break
        else
            print_error "   ❌ Invalid choice. Please enter a number between 1 and $max_choice."
            echo
        fi
    done
    
    # Set subtitle preference
    case $SELECTED_SUBTITLE_INDEX in
        1)
            SUBTITLE_OPTION="none"
            SUBTITLE_DESC="🚫 No subtitles"
            ;;
        2)
            SUBTITLE_OPTION="auto"
            SUBTITLE_DESC="🌍 Auto-select (English if available)"
            ;;
        *)
            local sub_index=$((SELECTED_SUBTITLE_INDEX - 3))
            local selected_sub="${AVAILABLE_SUBTITLES[$sub_index]}"
            local lang_code=$(echo "$selected_sub" | cut -d'|' -f1)
            local lang_name=$(echo "$selected_sub" | cut -d'|' -f2)
            SUBTITLE_OPTION="$lang_code"
            SUBTITLE_DESC="🔤 $lang_name ($lang_code)"
            ;;
    esac
    
    echo
    print_success "✅ Selected: $SUBTITLE_DESC"
    echo
}

# Function to confirm download
confirm_download() {
    local format_desc="${FORMAT_DESCRIPTIONS[$SELECTED_FORMAT_INDEX]}"
    
    echo -e "${YELLOW}📥 Ready to download:${NC}"
    echo -e "${WHITE}   Format: $format_desc${NC}"
    echo -e "${WHITE}   Subtitles: $SUBTITLE_DESC${NC}"
    echo -e "${WHITE}   Destination: $DOWNLOADS_DIR${NC}"
    echo
    
    while true; do
        echo -e "${CYAN}🤔 Proceed with download? (y/n): ${NC}"
        read -n 1 -r answer
        echo
        
        case $answer in
            [Yy]*)
                return 0
                ;;
            [Nn]*)
                return 1
                ;;
            *)
                print_error "   ❌ Please answer y (yes) or n (no)."
                ;;
        esac
    done
}

# Function to show progress bar
show_progress() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    
    printf "\r${CYAN}📊 Progress: ${WHITE}["
    printf "%*s" $filled | tr ' ' '█'
    printf "%*s" $empty | tr ' ' '░'
    printf "] ${BOLD}%d%%${NC} " $percentage
}

# Function to download video
download_video() {
    local url="$1"
    local format_code="${AVAILABLE_FORMATS[$SELECTED_FORMAT_INDEX]}"
    
    print_info "🚀 Starting download..."
    echo
    
    # Build yt-dlp command
    local cmd="yt-dlp"
    cmd+=" -f \"$format_code\""
    cmd+=" -o \"$DOWNLOADS_DIR/%(title)s.%(ext)s\""
    cmd+=" --add-metadata"
    cmd+=" --embed-thumbnail"
    cmd+=" --newline"
    cmd+=" --no-warnings"
    
    # Add subtitle options
    case $SUBTITLE_OPTION in
        "none")
            # No subtitles
            ;;
        "auto")
            cmd+=" --write-subs --sub-lang en,en-US,en-GB --skip-unavailable-fragments"
            ;;
        *)
            cmd+=" --write-subs --sub-lang $SUBTITLE_OPTION --skip-unavailable-fragments"
            ;;
    esac
    
    cmd+=" \"$url\""
    
    print_dim "🔧 Command: $cmd"
    echo
    
    # Create a temporary file for download output
    local temp_output="$TEMP_DIR/download_output.txt"
    local progress_file="$TEMP_DIR/progress.txt"
    
    print_info "📡 Initializing download..."
    echo
    
    # Execute download in background and capture output
    (eval "$cmd" 2>&1) | while IFS= read -r line; do
        echo "$line" >> "$temp_output"
        
        # Parse download progress
        if [[ "$line" =~ \[download\].*([0-9]+\.[0-9]+)%.*of.*([0-9]+\.[0-9]+[MKG]iB) ]]; then
            local percent="${BASH_REMATCH[1]}"
            local size="${BASH_REMATCH[2]}"
            
            # Clean display
            printf "\r\033[K"
            printf "${CYAN}📥 Downloading... ${WHITE}${BOLD}${percent}%%${NC} ${GRAY}(${size})${NC}"
            
        elif [[ "$line" =~ \[download\].*100% ]]; then
            printf "\r\033[K"
            print_success "✅ Video download completed!"
            
        elif [[ "$line" =~ \[info\].*Writing.*subtitles ]]; then
            print_info "📝 Downloading subtitles..."
            
        elif [[ "$line" =~ \[Merger\] ]]; then
            print_info "🔄 Merging video and audio..."
            
        elif [[ "$line" =~ Deleting.*original.*file ]]; then
            # Ignore cleanup messages
            continue
            
        elif [[ "$line" =~ \[ffmpeg\] ]]; then
            print_info "🎬 Processing video..."
            
        elif [[ "$line" =~ ERROR ]]; then
            echo
            print_error "❌ Error: $line"
            return 1
        fi
    done
    
    # Wait for background process to complete
    wait
    
    echo
    echo
    
    # Check if download was successful
    if grep -q "ERROR" "$temp_output" 2>/dev/null; then
        print_error "❌ Download failed!"
        echo
        return 1
    else
        print_success "🎉 Download completed successfully!"
        print_success "📁 Files saved to: $DOWNLOADS_DIR"
        
        # Show what was downloaded
        if [[ "$SUBTITLE_OPTION" != "none" ]]; then
            print_info "📝 Subtitles: $SUBTITLE_DESC"
        fi
        
        # Show final file info
        local video_file=$(grep -o "$DOWNLOADS_DIR/[^\"]*\.\(mp4\|webm\|mkv\)" "$temp_output" 2>/dev/null | head -1)
        if [[ -n "$video_file" && -f "$video_file" ]]; then
            local file_size=$(du -h "$video_file" 2>/dev/null | cut -f1)
            print_info "📏 File size: $file_size"
        fi
        
        echo
    fi
}

# Function to get time-based greeting
get_time_greeting() {
    local hour=$(date +%H)
    
    if [[ $hour -ge 5 && $hour -lt 12 ]]; then
        echo "morning"
    elif [[ $hour -ge 12 && $hour -lt 17 ]]; then
        echo "afternoon"
    elif [[ $hour -ge 17 && $hour -lt 21 ]]; then
        echo "evening"
    else
        echo "night"
    fi
}

# Function to ask for another download
ask_continue() {
    echo
    draw_separator
    echo
    print_header "🎯 What would you like to do next?"
    echo
    echo -e "${WHITE}   1.${NC} 🔄 Download another video"
    echo -e "${WHITE}   2.${NC} 🚪 Exit application"
    echo
    draw_separator
    echo
    
    while true; do
        echo -e "${CYAN}👆 Please select an option (1-2): ${NC}"
        read -r choice
        
        case $choice in
            1)
                print_success "✅ Great! Let's download another video."
                echo
                return 0
                ;;
            2)
                local username=$(get_username)
                local time_period=$(get_time_greeting)
                echo
                print_success "👋 Thank you ${BOLD}${WHITE}$username${NC}${GREEN}! Have a great $time_period!"
                echo
                return 1
                ;;
            *)
                print_error "   ❌ Invalid choice. Please enter 1 or 2."
                echo
                ;;
        esac
    done
}

# Function to show goodbye message
show_goodbye() {
    # This function is no longer needed as goodbye is handled in ask_continue
    return 0
}

# Main function
main() {
    # Show welcome screen first
    show_welcome
    
    # Check dependencies after welcome
    check_dependencies
    
    # Main loop
    while true; do
        # Get YouTube URL
        echo -e "${CYAN}🔗 Please enter YouTube URL: ${NC}"
        read -r url
        echo
        
        # Validate URL
        if ! validate_url "$url"; then
            print_error "❌ Invalid YouTube URL. Please try again."
            echo
            continue
        fi
        
        # Get video information
        if ! get_video_info "$url"; then
            continue
        fi
        
        # Get available formats
        get_available_formats "$url"
        
        # Show format menu
        show_format_menu
        
        # Get user choice
        get_user_choice
        
        # Check for subtitles and get subtitle choice
        if check_subtitles "$url"; then
            show_subtitle_options
            get_subtitle_choice
        else
            SUBTITLE_OPTION="none"
            SUBTITLE_DESC="🚫 No subtitles available"
            print_warning "⚠️  No subtitles available for this video"
            echo
        fi
        
        # Confirm download
        if confirm_download; then
            # Download video
            download_video "$url"
        else
            print_warning "⏹️  Download cancelled."
            echo
        fi
        
        # Ask if user wants to continue
        if ! ask_continue; then
            break
        fi
        
        # Clear screen for next iteration
        clear
        show_welcome
    done
}

# Run main function
main "$@"