#!/bin/bash

# Interactive YouTube Downloader CLI
# A beautiful, user-friendly YouTube video downloader
# Author: Your Name
# Version: 1.0.0

set -e

# Colors for beautiful UI
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Configuration
DOWNLOADS_DIR="$HOME/Downloads/YouTube Videos"
TEMP_DIR="/tmp/ytdl_$$"

# Create necessary directories
mkdir -p "$DOWNLOADS_DIR"
mkdir -p "$TEMP_DIR"

# Cleanup function
cleanup() {
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# Function to print colored output with emojis
print_header() {
    echo -e "${PURPLE}${BOLD}$1${NC}"
}

print_info() {
    echo -e "${CYAN}$1${NC}"
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

print_error() {
    echo -e "${RED}$1${NC}"
}

print_dim() {
    echo -e "${GRAY}${DIM}$1${NC}"
}

# Function to draw a separator line
draw_separator() {
    echo -e "${GRAY}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
}

# Function to get username
get_username() {
    local username=""
    if [[ -n "$USER" ]]; then
        username="$USER"
    elif [[ -n "$LOGNAME" ]]; then
        username="$LOGNAME"
    elif command -v whoami &> /dev/null; then
        username=$(whoami)
    else
        username="User"
    fi
    echo "$username"
}

# Function to check dependencies
check_dependencies() {
    print_info "ğŸ” Checking system requirements..."
    echo
    
    # Check if we're on macOS
    if [[ "$OSTYPE" != "darwin"* ]]; then
        print_error "âŒ This script currently supports macOS only."
        print_info "ğŸ’¡ Please ensure yt-dlp and ffmpeg are installed manually."
        echo
        exit 1
    fi
    
    print_info "ğŸ’» System: macOS"
    
    # Check for Homebrew
    local brew_installed=true
    if ! command -v brew &> /dev/null; then
        brew_installed=false
        print_warning "âš ï¸  Homebrew is not installed."
        print_info "ğŸ“ Homebrew is a package manager for macOS that makes installing software easy."
        echo
        
        if ask_install_permission "Homebrew"; then
            print_info "ğŸ“¦ Installing Homebrew..."
            print_dim "This may take a few minutes..."
            echo
            
            # Install Homebrew
            if /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
                print_success "âœ… Homebrew installed successfully!"
                
                # Add Homebrew to PATH for current session
                if [[ -f "/opt/homebrew/bin/brew" ]]; then
                    export PATH="/opt/homebrew/bin:$PATH"
                elif [[ -f "/usr/local/bin/brew" ]]; then
                    export PATH="/usr/local/bin:$PATH"
                fi
                
                brew_installed=true
                echo
            else
                print_error "âŒ Failed to install Homebrew"
                print_info "ğŸ’¡ Please install Homebrew manually and run this script again:"
                print_info "   /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                echo
                exit 1
            fi
        else
            print_error "âŒ Homebrew is required for automatic package installation."
            print_info "ğŸ’¡ Please install Homebrew manually and run this script again:"
            print_info "   /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            echo
            exit 1
        fi
    else
        print_success "âœ… Homebrew is installed"
    fi
    
    # Check required packages
    local missing_packages=()
    
    if ! command -v yt-dlp &> /dev/null; then
        missing_packages+=("yt-dlp")
    fi
    
    if ! command -v ffmpeg &> /dev/null; then
        missing_packages+=("ffmpeg")
    fi
    
    # Install missing packages if any
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        echo
        print_warning "âš ï¸  Missing required packages:"
        for package in "${missing_packages[@]}"; do
            print_warning "   â€¢ $package"
        done
        echo
        
        print_info "ğŸ“ These packages are required for the YouTube downloader to work:"
        print_info "   â€¢ yt-dlp: Core tool for downloading YouTube videos"
        print_info "   â€¢ ffmpeg: Required for merging video/audio and processing media"
        echo
        
        if ask_install_permission "the required packages (yt-dlp and ffmpeg)"; then
            print_info "ğŸ“¦ Installing required packages..."
            echo
            
            local install_success=true
            
            for package in "${missing_packages[@]}"; do
                print_info "ğŸ”„ Installing $package..."
                if brew install "$package"; then
                    print_success "âœ… $package installed successfully!"
                else
                    print_error "âŒ Failed to install $package"
                    install_success=false
                fi
                echo
            done
            
            if [[ "$install_success" == true ]]; then
                print_success "ğŸ‰ All required packages installed successfully!"
            else
                print_error "âŒ Some packages failed to install. Please install them manually:"
                for package in "${missing_packages[@]}"; do
                    print_info "   brew install $package"
                done
                echo
                exit 1
            fi
        else
            print_error "âŒ Required packages are needed for the app to work."
            print_info "ğŸ’¡ You can install them manually with:"
            for package in "${missing_packages[@]}"; do
                print_info "   brew install $package"
            done
            echo
            exit 1
        fi
    else
        print_success "âœ… All required packages are installed"
    fi
    
    # Install jq quietly if not present (for JSON parsing)
    if ! command -v jq &> /dev/null; then
        print_info "ğŸ“¦ Installing jq (JSON processor)..."
        brew install jq >/dev/null 2>&1 || print_warning "âš ï¸  Could not install jq. Some features may be limited."
    fi
    
    echo
    draw_separator
    echo
}

# Function to ask user for installation permission
ask_install_permission() {
    local item="$1"
    
    while true; do
        echo -e "${CYAN}ğŸ¤” Would you like to install $item now? (y/n): ${NC}"
        read -n 1 -r answer
        echo
        
        case $answer in
            [Yy]*)
                return 0
                ;;
            [Nn]*)
                return 1
                ;;
            *)
                print_error "   âŒ Please answer y (yes) or n (no)."
                ;;
        esac
    done
}

# Function to validate YouTube URL
validate_url() {
    local url="$1"
    if [[ $url =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
        return 0
    else
        return 1
    fi
}

# Function to show welcome screen
show_welcome() {
    clear
    local username=$(get_username)
    
    echo
    echo "ğŸ¬ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "    INTERACTIVE YOUTUBE DOWNLOADER"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo
    echo "    ğŸ‘‹ Hi $username! Welcome to Interactive YouTube Downloader"
    echo
    echo "    ğŸ“ Downloads will be saved to: $DOWNLOADS_DIR"
    echo "    ğŸ”§ Powered by yt-dlp and ffmpeg"
    echo
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo
}

# Function to get video information super quickly (just validate URL)
get_video_info_quick() {
    local url="$1"
    
    echo "ğŸ” Validating video..."
    
    # Just check if it's a valid YouTube URL format first
    if [[ ! "$url" =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
        echo "âŒ Invalid YouTube URL format"
        return 1
    fi
    
    # Quick title check with timeout
    echo -n "ğŸ“¡ Checking video"
    
    # Use timeout to prevent hanging
    local title=""
    if command -v timeout >/dev/null 2>&1; then
        # Linux/some systems have timeout command
        title=$(timeout 10 yt-dlp --get-title --no-warnings "$url" 2>/dev/null || echo "")
    else
        # macOS - use background process with kill
        {
            yt-dlp --get-title --no-warnings "$url" 2>/dev/null
            echo $? > "$TEMP_DIR/title_exit_code"
        } &
        local title_pid=$!
        
        # Wait max 10 seconds
        local count=0
        while kill -0 $title_pid 2>/dev/null && [[ $count -lt 20 ]]; do
            echo -n "."
            sleep 0.5
            ((count++))
        done
        
        # Kill if still running
        if kill -0 $title_pid 2>/dev/null; then
            kill $title_pid 2>/dev/null
            echo " Timeout!"
            echo "âŒ Video check timed out - the video might be private or restricted"
            return 1
        fi
        
        wait $title_pid 2>/dev/null
        title=$(cat "$TEMP_DIR/title_result" 2>/dev/null || echo "")
    fi
    
    echo " Done!"
    
    if [[ -n "$title" && "$title" != "" ]]; then
        echo "âœ… Video found: $title"
        echo
        return 0
    else
        echo "âŒ Could not access video"
        echo "   The video might be private, restricted, or the URL is invalid"
        echo
        return 1
    fi
}

# Function to get available formats with basic info only
get_available_formats_quick() {
    local url="$1"
    local formats_file="$TEMP_DIR/formats.txt"
    
    echo "ğŸ” Getting download options..."
    echo -n "ğŸ“Š Scanning"
    
    # Get format list quickly
    {
        yt-dlp -F "$url" --no-warnings 2>/dev/null > "$formats_file"
        echo $? > "$TEMP_DIR/formats_exit_code"
    } &
    
    local formats_pid=$!
    
    # Simple dot animation
    while kill -0 $formats_pid 2>/dev/null; do
        echo -n "."
        sleep 0.2
    done
    
    wait $formats_pid
    local exit_code=$(cat "$TEMP_DIR/formats_exit_code" 2>/dev/null || echo "1")
    
    echo " Done!"
    echo
    
    if [[ "$exit_code" -eq 0 ]]; then
        echo "âœ… Found download options!"
        echo
    else
        echo "âŒ Failed to get download options"
        return 1
    fi
    
    # Parse formats quickly - detect all quality levels
    local video_formats=()
    local format_descriptions=()
    
    # Add audio-only option
    video_formats+=("bestaudio")
    format_descriptions+=("ğŸµ Audio Only")
    
    # Quality detection flags
    local found_8k=false
    local found_4k=false
    local found_2k=false
    local found_1080p=false
    local found_720p=false
    local found_480p=false
    
    while IFS= read -r line; do
        if [[ "$line" =~ ^[0-9]+ ]] && [[ "$line" =~ video ]] && [[ ! "$line" =~ "audio only" ]]; then
            local format_id=$(echo "$line" | awk '{print $1}')
            local ext=$(echo "$line" | awk '{print $2}')
            local resolution=$(echo "$line" | awk '{print $3}')
            
            # Detect and include quality levels available
            if [[ "$resolution" =~ "7680x4320" || "$resolution" =~ "4320" ]] && [[ "$found_8k" == false ]]; then
                video_formats+=("$format_id")
                format_descriptions+=("ğŸŒŸ 8K UHD [$ext]")
                found_8k=true
            elif [[ "$resolution" =~ "3840x2160" || "$resolution" =~ "2160" ]] && [[ "$found_4k" == false ]]; then
                video_formats+=("$format_id")
                format_descriptions+=("ğŸ† 4K UHD [$ext]")
                found_4k=true
            elif [[ "$resolution" =~ "2560x1440" || "$resolution" =~ "1440" ]] && [[ "$found_2k" == false ]]; then
                video_formats+=("$format_id")
                format_descriptions+=("ğŸ’ 2K QHD [$ext]")
                found_2k=true
            elif [[ "$resolution" =~ "1920x1080" || "$resolution" =~ "1080" ]] && [[ "$found_1080p" == false ]]; then
                video_formats+=("$format_id")
                format_descriptions+=("â­ Full HD [$ext]")
                found_1080p=true
            elif [[ "$resolution" =~ "1280x720" || "$resolution" =~ "720" ]] && [[ "$found_720p" == false ]]; then
                video_formats+=("$format_id")
                format_descriptions+=("ğŸ“º HD [$ext]")
                found_720p=true
            elif [[ "$resolution" =~ "854x480" || "$resolution" =~ "640x480" || "$resolution" =~ "480" ]] && [[ "$found_480p" == false ]]; then
                video_formats+=("$format_id")
                format_descriptions+=("ğŸ“± SD [$ext]")
                found_480p=true
            fi
        fi
    done < "$formats_file"
    
    # Add best quality option
    video_formats+=("best")
    format_descriptions+=("ğŸš€ Best Available")
    
    # Store in global arrays
    AVAILABLE_FORMATS=("${video_formats[@]}")
    FORMAT_DESCRIPTIONS=("${format_descriptions[@]}")
}

# Function to check subtitles quickly
check_subtitles_quick() {
    local url="$1"
    
    echo -n "ğŸ“ Checking subtitles"
    
    # Quick subtitle check
    local subs_output=$(yt-dlp --list-subs "$url" --no-warnings 2>/dev/null)
    local has_subs=$(echo "$subs_output" | grep -c "Available subtitles" || echo "0")
    
    echo " Done!"
    
    if [[ $has_subs -gt 0 ]]; then
        echo "âœ… Subtitles available"
        echo
        
        # Parse actual available languages quickly
        local available_subs=()
        while IFS= read -r line; do
            if [[ "$line" =~ ^[a-z]{2}(-[A-Z]{2})? ]]; then
                local lang_code=$(echo "$line" | awk '{print $1}')
                local lang_name=$(echo "$line" | cut -d' ' -f2- | sed 's/^[[:space:]]*//' | cut -d',' -f1)
                available_subs+=("$lang_code|$lang_name")
                
                # Limit to first 8 languages for speed
                if [[ ${#available_subs[@]} -ge 8 ]]; then
                    break
                fi
            fi
        done <<< "$subs_output"
        
        if [[ ${#available_subs[@]} -gt 0 ]]; then
            AVAILABLE_SUBTITLES=("${available_subs[@]}")
            return 0
        fi
    fi
    
    # No subtitles found
    echo "âš ï¸  No subtitles available"
    echo
    return 1
}

# Function to get available formats with simple loading
get_available_formats() {
    local url="$1"
    local formats_file="$TEMP_DIR/formats.txt"
    
    echo "ğŸ” Analyzing available formats..."
    echo -n "ğŸ“Š Scanning"
    
    # Start background process
    {
        yt-dlp -F "$url" --no-warnings 2>/dev/null > "$formats_file"
        echo $? > "$TEMP_DIR/formats_exit_code"
    } &
    
    local formats_pid=$!
    
    # Simple dot animation
    while kill -0 $formats_pid 2>/dev/null; do
        echo -n "."
        sleep 0.3
    done
    
    # Wait and get exit code
    wait $formats_pid
    local exit_code=$(cat "$TEMP_DIR/formats_exit_code" 2>/dev/null || echo "1")
    
    echo " Done!"
    echo
    
    if [[ "$exit_code" -eq 0 ]]; then
        echo "âœ… Quality analysis complete!"
        echo
    else
        echo "âŒ Failed to analyze available formats"
        return 1
    fi
    
    # Parse video formats
    local video_formats=()
    local format_descriptions=()
    
    # Add audio-only option
    video_formats+=("bestaudio")
    format_descriptions+=("ğŸµ Audio Only (Best Quality)")
    
    # Parse available video formats
    while IFS= read -r line; do
        if [[ "$line" =~ ^[0-9]+ ]] && [[ "$line" =~ video ]] && [[ ! "$line" =~ "audio only" ]]; then
            local format_id=$(echo "$line" | awk '{print $1}')
            local ext=$(echo "$line" | awk '{print $2}')
            local resolution=$(echo "$line" | awk '{print $3}')
            local fps=$(echo "$line" | grep -o '[0-9]*fps' || echo "")
            local filesize=$(echo "$line" | grep -o '[0-9.]*[MG]iB' || echo "")
            
            # Determine quality emoji and label
            local quality_emoji=""
            local quality_label=""
            
            if [[ "$resolution" =~ "3840x2160" || "$resolution" =~ "2160" ]]; then
                quality_emoji="ğŸ†"
                quality_label="4K UHD"
            elif [[ "$resolution" =~ "2560x1440" || "$resolution" =~ "1440" ]]; then
                quality_emoji="ğŸ’"
                quality_label="2K QHD"
            elif [[ "$resolution" =~ "1920x1080" || "$resolution" =~ "1080" ]]; then
                quality_emoji="â­"
                quality_label="Full HD"
            elif [[ "$resolution" =~ "1280x720" || "$resolution" =~ "720" ]]; then
                quality_emoji="ğŸ“º"
                quality_label="HD"
            elif [[ "$resolution" =~ "480" ]]; then
                quality_emoji="ğŸ“±"
                quality_label="SD"
            else
                quality_emoji="ğŸ“¹"
                quality_label="$resolution"
            fi
            
            # Build description
            local description="$quality_emoji $quality_label"
            [[ -n "$resolution" ]] && description+=" ($resolution)"
            [[ -n "$ext" ]] && description+=" [$ext]"
            [[ -n "$fps" ]] && description+=" $fps"
            [[ -n "$filesize" ]] && description+=" - $filesize"
            
            video_formats+=("$format_id")
            format_descriptions+=("$description")
        fi
    done < "$formats_file"
    
    # Add best quality option
    video_formats+=("best")
    format_descriptions+=("ğŸš€ Best Available (Auto-select)")
    
    # Store in global arrays
    AVAILABLE_FORMATS=("${video_formats[@]}")
    FORMAT_DESCRIPTIONS=("${format_descriptions[@]}")
}

# Function to show format options menu
show_format_menu() {
    echo
    print_header "ğŸ“‹ Available Download Options:"
    draw_separator
    
    for i in "${!FORMAT_DESCRIPTIONS[@]}"; do
        local num=$((i + 1))
        echo -e "${WHITE}   $num.${NC} ${FORMAT_DESCRIPTIONS[$i]}"
    done
    
    draw_separator
    echo
}

# Function to get user choice with input validation
get_user_choice() {
    local max_choice=${#AVAILABLE_FORMATS[@]}
    local choice=""
    
    while true; do
        # Clear input buffer
        while read -r -t 0; do
            read -r
        done
        
        echo -n "ğŸ¯ Select download option (1-$max_choice): "
        read -r choice
        
        # Check if choice is a number and within range
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $max_choice ]]; then
            SELECTED_FORMAT_INDEX=$((choice - 1))
            break
        else
            echo "   âŒ Invalid choice. Please enter a number between 1 and $max_choice."
            echo
        fi
    done
    
    echo
    echo "âœ… Selected: ${FORMAT_DESCRIPTIONS[$SELECTED_FORMAT_INDEX]}"
    echo
}

# Function to check available subtitles with simple loading
check_subtitles() {
    local url="$1"
    local subs_file="$TEMP_DIR/subtitles.txt"
    
    echo -n "ğŸ“ Checking subtitles"
    
    # Start background process
    {
        yt-dlp --list-subs "$url" --no-warnings 2>/dev/null > "$subs_file"
        echo $? > "$TEMP_DIR/subs_exit_code"
    } &
    
    local subs_pid=$!
    
    # Simple dot animation
    while kill -0 $subs_pid 2>/dev/null; do
        echo -n "."
        sleep 0.4
    done
    
    # Wait and get exit code
    wait $subs_pid
    local exit_code=$(cat "$TEMP_DIR/subs_exit_code" 2>/dev/null || echo "1")
    
    echo " Done!"
    echo
    
    if [[ "$exit_code" -eq 0 ]] && grep -q "Available subtitles" "$subs_file"; then
        echo "âœ… Subtitles found!"
        
        # Parse available subtitle languages
        local available_subs=()
        while IFS= read -r line; do
            if [[ "$line" =~ ^[a-z]{2}(-[A-Z]{2})? ]]; then
                local lang_code=$(echo "$line" | awk '{print $1}')
                local lang_name=$(echo "$line" | cut -d' ' -f2- | sed 's/^[[:space:]]*//')
                available_subs+=("$lang_code|$lang_name")
            fi
        done < "$subs_file"
        
        if [[ ${#available_subs[@]} -gt 0 ]]; then
            AVAILABLE_SUBTITLES=("${available_subs[@]}")
            return 0
        fi
    fi
    
    echo "âš ï¸  No subtitles available"
    return 1
}

# Function to show subtitle options
show_subtitle_options() {
    echo
    print_header "ğŸ“ Subtitle Options:"
    draw_separator
    
    echo -e "${WHITE}   1.${NC} ğŸš« No subtitles"
    echo -e "${WHITE}   2.${NC} ğŸŒ Auto-select (English if available)"
    
    local counter=3
    for sub in "${AVAILABLE_SUBTITLES[@]}"; do
        local lang_code=$(echo "$sub" | cut -d'|' -f1)
        local lang_name=$(echo "$sub" | cut -d'|' -f2)
        echo -e "${WHITE}   $counter.${NC} ğŸ”¤ $lang_name ($lang_code)"
        ((counter++))
    done
    
    draw_separator
    echo
}

# Function to get subtitle choice
get_subtitle_choice() {
    local max_choice=$((2 + ${#AVAILABLE_SUBTITLES[@]}))
    local choice=""
    
    while true; do
        echo -e "${CYAN}ğŸ“ Select subtitle option (1-$max_choice): ${NC}"
        read -r choice
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $max_choice ]]; then
            SELECTED_SUBTITLE_INDEX=$choice
            break
        else
            print_error "   âŒ Invalid choice. Please enter a number between 1 and $max_choice."
            echo
        fi
    done
    
    # Set subtitle preference
    case $SELECTED_SUBTITLE_INDEX in
        1)
            SUBTITLE_OPTION="none"
            SUBTITLE_DESC="ğŸš« No subtitles"
            ;;
        2)
            SUBTITLE_OPTION="auto"
            SUBTITLE_DESC="ğŸŒ Auto-select (English if available)"
            ;;
        *)
            local sub_index=$((SELECTED_SUBTITLE_INDEX - 3))
            local selected_sub="${AVAILABLE_SUBTITLES[$sub_index]}"
            local lang_code=$(echo "$selected_sub" | cut -d'|' -f1)
            local lang_name=$(echo "$selected_sub" | cut -d'|' -f2)
            SUBTITLE_OPTION="$lang_code"
            SUBTITLE_DESC="ğŸ”¤ $lang_name ($lang_code)"
            ;;
    esac
    
    echo
    print_success "âœ… Selected: $SUBTITLE_DESC"
    echo
}

# Function to confirm download
confirm_download() {
    local format_desc="${FORMAT_DESCRIPTIONS[$SELECTED_FORMAT_INDEX]}"
    
    echo -e "${YELLOW}ğŸ“¥ Ready to download:${NC}"
    echo -e "${WHITE}   Format: $format_desc${NC}"
    echo -e "${WHITE}   Subtitles: $SUBTITLE_DESC${NC}"
    echo -e "${WHITE}   Destination: $DOWNLOADS_DIR${NC}"
    echo
    
    while true; do
        echo -e "${CYAN}ğŸ¤” Proceed with download? (y/n): ${NC}"
        read -n 1 -r answer
        echo
        
        case $answer in
            [Yy]*)
                return 0
                ;;
            [Nn]*)
                return 1
                ;;
            *)
                print_error "   âŒ Please answer y (yes) or n (no)."
                ;;
        esac
    done
}

# Function to show progress bar
show_progress() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    
    printf "\r${CYAN}ğŸ“Š Progress: ${WHITE}["
    printf "%*s" $filled | tr ' ' 'â–ˆ'
    printf "%*s" $empty | tr ' ' 'â–‘'
    printf "] ${BOLD}%d%%${NC} " $percentage
}

# Function to download video
download_video() {
    local url="$1"
    local format_code="${AVAILABLE_FORMATS[$SELECTED_FORMAT_INDEX]}"
    
    print_info "ğŸš€ Starting download..."
    echo
    
    # Build yt-dlp command
    local cmd="yt-dlp"
    cmd+=" -f \"$format_code\""
    cmd+=" -o \"$DOWNLOADS_DIR/%(title)s.%(ext)s\""
    cmd+=" --add-metadata"
    cmd+=" --embed-thumbnail"
    cmd+=" --newline"
    cmd+=" --no-warnings"
    
    # Add subtitle options
    case $SUBTITLE_OPTION in
        "none")
            # No subtitles
            ;;
        "auto")
            cmd+=" --write-subs --sub-lang en,en-US,en-GB --skip-unavailable-fragments"
            ;;
        *)
            cmd+=" --write-subs --sub-lang $SUBTITLE_OPTION --skip-unavailable-fragments"
            ;;
    esac
    
    cmd+=" \"$url\""
    
    print_dim "ğŸ”§ Command: $cmd"
    echo
    
    # Create a temporary file for download output
    local temp_output="$TEMP_DIR/download_output.txt"
    local progress_file="$TEMP_DIR/progress.txt"
    
    print_info "ğŸ“¡ Initializing download..."
    echo
    
    # Execute download in background and capture output
    (eval "$cmd" 2>&1) | while IFS= read -r line; do
        echo "$line" >> "$temp_output"
        
        # Parse download progress
        if [[ "$line" =~ \[download\].*([0-9]+\.[0-9]+)%.*of.*([0-9]+\.[0-9]+[MKG]iB) ]]; then
            local percent="${BASH_REMATCH[1]}"
            local size="${BASH_REMATCH[2]}"
            
            # Clean display
            printf "\r\033[K"
            printf "${CYAN}ğŸ“¥ Downloading... ${WHITE}${BOLD}${percent}%%${NC} ${GRAY}(${size})${NC}"
            
        elif [[ "$line" =~ \[download\].*100% ]]; then
            printf "\r\033[K"
            print_success "âœ… Video download completed!"
            
        elif [[ "$line" =~ \[info\].*Writing.*subtitles ]]; then
            print_info "ğŸ“ Downloading subtitles..."
            
        elif [[ "$line" =~ \[Merger\] ]]; then
            print_info "ğŸ”„ Merging video and audio..."
            
        elif [[ "$line" =~ Deleting.*original.*file ]]; then
            # Ignore cleanup messages
            continue
            
        elif [[ "$line" =~ \[ffmpeg\] ]]; then
            print_info "ğŸ¬ Processing video..."
            
        elif [[ "$line" =~ ERROR ]]; then
            echo
            print_error "âŒ Error: $line"
            return 1
        fi
    done
    
    # Wait for background process to complete
    wait
    
    echo
    echo
    
    # Check if download was successful
    if grep -q "ERROR" "$temp_output" 2>/dev/null; then
        print_error "âŒ Download failed!"
        echo
        return 1
    else
        print_success "ğŸ‰ Download completed successfully!"
        print_success "ğŸ“ Files saved to: $DOWNLOADS_DIR"
        
        # Show what was downloaded
        if [[ "$SUBTITLE_OPTION" != "none" ]]; then
            print_info "ğŸ“ Subtitles: $SUBTITLE_DESC"
        fi
        
        # Show final file info
        local video_file=$(grep -o "$DOWNLOADS_DIR/[^\"]*\.\(mp4\|webm\|mkv\)" "$temp_output" 2>/dev/null | head -1)
        if [[ -n "$video_file" && -f "$video_file" ]]; then
            local file_size=$(du -h "$video_file" 2>/dev/null | cut -f1)
            print_info "ğŸ“ File size: $file_size"
        fi
        
        echo
    fi
}

# Function to get time-based greeting
get_time_greeting() {
    local hour=$(date +%H)
    
    if [[ $hour -ge 5 && $hour -lt 12 ]]; then
        echo "morning"
    elif [[ $hour -ge 12 && $hour -lt 17 ]]; then
        echo "afternoon"
    elif [[ $hour -ge 17 && $hour -lt 21 ]]; then
        echo "evening"
    else
        echo "night"
    fi
}

# Function to ask for another download
ask_continue() {
    echo
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo
    echo "ğŸ¯ What would you like to do next?"
    echo
    echo "   1. ğŸ”„ Download another video"
    echo "   2. ğŸšª Exit application"
    echo
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo
    
    while true; do
        echo -n "ğŸ‘† Please select an option (1-2): "
        read -r choice
        
        case $choice in
            1)
                echo "âœ… Great! Let's download another video."
                echo
                return 0
                ;;
            2)
                local username=$(get_username)
                local time_period=$(get_time_greeting)
                echo
                echo "ğŸ‘‹ Thank you $username! Have a great $time_period!"
                echo
                return 1
                ;;
            *)
                echo "   âŒ Invalid choice. Please enter 1 or 2."
                echo
                ;;
        esac
    done
}

# Function to show goodbye message
show_goodbye() {
    # This function is no longer needed as goodbye is handled in ask_continue
    return 0
}

# Main function
main() {
    # Show welcome screen first
    show_welcome
    
    # Check dependencies after welcome
    check_dependencies
    
    # Main loop
    while true; do
        # Clear any input buffer before asking for URL
        while read -r -t 0; do
            read -r
        done
        
        # Get YouTube URL with validation
        echo -n "ğŸ”— Please enter YouTube URL: "
        read -r url
        echo
        
        # Validate URL format first
        if [[ -z "$url" ]]; then
            echo "âŒ No URL entered. Please try again."
            echo
            continue
        fi
        
        # Check if it looks like a YouTube URL
        if [[ ! "$url" =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
            echo "âŒ Please enter a valid YouTube URL (youtube.com or youtu.be)"
            echo
            continue
        fi
        
        # Clean the URL (remove extra parameters that might cause issues)
        url=$(echo "$url" | sed 's/&list=.*//' | sed 's/&start_radio=.*//' | sed 's/&t=.*//')
        
        echo "ğŸ”— Using URL: $url"
        echo
        
        # Validate URL
        if ! validate_url "$url"; then
            echo "âŒ Invalid YouTube URL format. Please try again."
            echo
            continue
        fi
        
        # Get video information quickly
        if ! get_video_info_quick "$url"; then
            continue
        fi
        
        # Get available formats quickly
        get_available_formats_quick "$url"
        
        # Show format menu
        show_format_menu
        
        # Get user choice
        get_user_choice
        
        # Check for subtitles quickly
        if check_subtitles_quick "$url"; then
            show_subtitle_options
            get_subtitle_choice
        else
            SUBTITLE_OPTION="none"
            SUBTITLE_DESC="ğŸš« No subtitles available"
            # No need to show subtitle menu if none are available
        fi
        
        # Confirm download
        if confirm_download; then
            # Download video
            download_video "$url"
        else
            print_warning "â¹ï¸  Download cancelled."
            echo
        fi
        
        # Ask if user wants to continue
        if ! ask_continue; then
            break
        fi
        
        # Clear screen for next iteration
        clear
        show_welcome
    done
}

# Run main function
main "$@"