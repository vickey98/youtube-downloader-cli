#!/bin/bash

# Interactive YouTube Downloader CLI
# A beautiful, user-friendly YouTube video downloader
# Author: Your Name
# Version: 1.0.0

set -e

# Colors for beautiful UI
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Configuration
DOWNLOADS_DIR="$HOME/Downloads/YouTube Videos"
TEMP_DIR="/tmp/ytdl_$$"

# Create necessary directories
mkdir -p "$DOWNLOADS_DIR"
mkdir -p "$TEMP_DIR"

# Cleanup function
cleanup() {
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# Function to print colored output with emojis
print_header() {
    echo -e "${PURPLE}${BOLD}$1${NC}"
}

print_info() {
    echo -e "${CYAN}$1${NC}"
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

print_error() {
    echo -e "${RED}$1${NC}"
}

print_dim() {
    echo -e "${GRAY}${DIM}$1${NC}"
}

# Function to draw a separator line
draw_separator() {
    echo -e "${GRAY}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
}

# Function to get username
get_username() {
    local username=""
    if [[ -n "$USER" ]]; then
        username="$USER"
    elif [[ -n "$LOGNAME" ]]; then
        username="$LOGNAME"
    elif command -v whoami &> /dev/null; then
        username=$(whoami)
    else
        username="User"
    fi
    echo "$username"
}

# Function to check dependencies
check_dependencies() {
    print_info "üîç Checking system requirements..."
    echo
    
    # Check if we're on macOS
    if [[ "$OSTYPE" != "darwin"* ]]; then
        print_error "‚ùå This script currently supports macOS only."
        print_info "üí° Please ensure yt-dlp and ffmpeg are installed manually."
        echo
        exit 1
    fi
    
    print_info "üíª System: macOS"
    
    # Check for Homebrew
    local brew_installed=true
    if ! command -v brew &> /dev/null; then
        brew_installed=false
        print_warning "‚ö†Ô∏è  Homebrew is not installed."
        print_info "üìù Homebrew is a package manager for macOS that makes installing software easy."
        echo
        
        if ask_install_permission "Homebrew"; then
            print_info "üì¶ Installing Homebrew..."
            print_dim "This may take a few minutes..."
            echo
            
            # Install Homebrew
            if /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
                print_success "‚úÖ Homebrew installed successfully!"
                
                # Add Homebrew to PATH for current session
                if [[ -f "/opt/homebrew/bin/brew" ]]; then
                    export PATH="/opt/homebrew/bin:$PATH"
                elif [[ -f "/usr/local/bin/brew" ]]; then
                    export PATH="/usr/local/bin:$PATH"
                fi
                
                brew_installed=true
                echo
            else
                print_error "‚ùå Failed to install Homebrew"
                print_info "üí° Please install Homebrew manually and run this script again:"
                print_info "   /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                echo
                exit 1
            fi
        else
            print_error "‚ùå Homebrew is required for automatic package installation."
            print_info "üí° Please install Homebrew manually and run this script again:"
            print_info "   /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            echo
            exit 1
        fi
    else
        print_success "‚úÖ Homebrew is installed"
    fi
    
    # Check required packages
    local missing_packages=()
    
    if ! command -v yt-dlp &> /dev/null; then
        missing_packages+=("yt-dlp")
    fi
    
    if ! command -v ffmpeg &> /dev/null; then
        missing_packages+=("ffmpeg")
    fi
    
    # Install missing packages if any
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        echo
        print_warning "‚ö†Ô∏è  Missing required packages:"
        for package in "${missing_packages[@]}"; do
            print_warning "   ‚Ä¢ $package"
        done
        echo
        
        print_info "üìù These packages are required for the YouTube downloader to work:"
        print_info "   ‚Ä¢ yt-dlp: Core tool for downloading YouTube videos"
        print_info "   ‚Ä¢ ffmpeg: Required for merging video/audio and processing media"
        echo
        
        if ask_install_permission "the required packages (yt-dlp and ffmpeg)"; then
            print_info "üì¶ Installing required packages..."
            echo
            
            local install_success=true
            
            for package in "${missing_packages[@]}"; do
                print_info "üîÑ Installing $package..."
                if brew install "$package"; then
                    print_success "‚úÖ $package installed successfully!"
                else
                    print_error "‚ùå Failed to install $package"
                    install_success=false
                fi
                echo
            done
            
            if [[ "$install_success" == true ]]; then
                print_success "üéâ All required packages installed successfully!"
            else
                print_error "‚ùå Some packages failed to install. Please install them manually:"
                for package in "${missing_packages[@]}"; do
                    print_info "   brew install $package"
                done
                echo
                exit 1
            fi
        else
            print_error "‚ùå Required packages are needed for the app to work."
            print_info "üí° You can install them manually with:"
            for package in "${missing_packages[@]}"; do
                print_info "   brew install $package"
            done
            echo
            exit 1
        fi
    else
        print_success "‚úÖ All required packages are installed"
    fi
    
    # Install jq quietly if not present (for JSON parsing)
    if ! command -v jq &> /dev/null; then
        print_info "üì¶ Installing jq (JSON processor)..."
        brew install jq >/dev/null 2>&1 || print_warning "‚ö†Ô∏è  Could not install jq. Some features may be limited."
    fi
    
    echo
    draw_separator
    echo
}

# Function to ask user for installation permission
ask_install_permission() {
    local item="$1"
    
    while true; do
        echo -e "${CYAN}ü§î Would you like to install $item now? (y/n): ${NC}"
        read -n 1 -r answer
        echo
        
        case $answer in
            [Yy]*)
                return 0
                ;;
            [Nn]*)
                return 1
                ;;
            *)
                print_error "   ‚ùå Please answer y (yes) or n (no)."
                ;;
        esac
    done
}

# Function to validate YouTube URL
validate_url() {
    local url="$1"
    if [[ $url =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
        return 0
    else
        return 1
    fi
}

# Function to show welcome screen
show_welcome() {
    clear
    local username=$(get_username)
    
    echo
    echo "üé¨ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "    INTERACTIVE YOUTUBE DOWNLOADER"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo
    echo "    üëã Hi $username! Welcome to Interactive YouTube Downloader"
    echo
    echo "    üìÅ Downloads will be saved to: $DOWNLOADS_DIR"
    echo "    üîß Powered by yt-dlp and ffmpeg"
    echo
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo
}

# Function to get video information simply (just like the working command)
get_video_info_quick() {
    local url="$1"
    
    echo "üîç Validating video..."
    
    # Just check if it's a valid YouTube URL format first
    if [[ ! "$url" =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
        echo "‚ùå Invalid YouTube URL format"
        return 1
    fi
    
    # Simple validation - just try to get basic info like the working command
    echo -n "üì° Checking video"
    
    # Use the same approach as the working command - let yt-dlp handle everything
    if yt-dlp --no-download --quiet --print "%(title)s" "$url" >/dev/null 2>&1; then
        local title=$(yt-dlp --no-download --quiet --print "%(title)s" "$url" 2>/dev/null || echo "Video")
        echo " Done!"
        echo
        echo "‚úÖ Video found: $title"
        echo
        return 0
    else
        echo " Failed!"
        echo
        echo "‚ùå Could not access video"
        echo "   Please check if the URL is valid and the video is accessible"
        echo
        return 1
    fi
}

# Function to get available formats simply (like the working command)
get_available_formats_quick() {
    local url="$1"
    
    echo "üîç Getting download options..."
    echo -n "üìä Scanning"
    
    # Use the same approach as your working command - let yt-dlp do the work
    local formats_output=$(yt-dlp -F "$url" --no-warnings 2>/dev/null)
    local exit_code=$?
    
    echo " Done!"
    echo
    
    if [[ $exit_code -eq 0 ]]; then
        echo "‚úÖ Found download options!"
        echo
    else
        echo "‚ùå Failed to get download options"
        return 1
    fi
    
    # Parse formats simply - just look for the common ones that work
    local video_formats=()
    local format_descriptions=()
    
    # Add audio-only option (always works)
    video_formats+=("bestaudio")
    format_descriptions+=("üéµ Audio Only")
    
    # Add the proven working formats based on your command pattern
    video_formats+=("best[height<=2160]")
    format_descriptions+=("üèÜ 4K UHD (Best)")
    
    video_formats+=("best[height<=1440]")
    format_descriptions+=("üíé 2K QHD (Best)")
    
    video_formats+=("best[height<=1080]")
    format_descriptions+=("‚≠ê Full HD (Best)")
    
    video_formats+=("best[height<=720]")
    format_descriptions+=("üì∫ HD (Best)")
    
    video_formats+=("best")
    format_descriptions+=("üöÄ Best Available")
    
    # Store in global arrays
    AVAILABLE_FORMATS=("${video_formats[@]}")
    FORMAT_DESCRIPTIONS=("${format_descriptions[@]}")
}

# Function to check subtitles quickly
check_subtitles_quick() {
    local url="$1"
    
    echo -n "üìù Checking subtitles"
    
    # Quick subtitle check
    local subs_output=$(yt-dlp --list-subs "$url" --no-warnings 2>/dev/null)
    local has_subs=$(echo "$subs_output" | grep -c "Available subtitles" || echo "0")
    
    echo " Done!"
    
    if [[ $has_subs -gt 0 ]]; then
        echo "‚úÖ Subtitles available"
        echo
        
        # Parse actual available languages quickly
        local available_subs=()
        while IFS= read -r line; do
            if [[ "$line" =~ ^[a-z]{2}(-[A-Z]{2})? ]]; then
                local lang_code=$(echo "$line" | awk '{print $1}')
                local lang_name=$(echo "$line" | cut -d' ' -f2- | sed 's/^[[:space:]]*//' | cut -d',' -f1)
                available_subs+=("$lang_code|$lang_name")
                
                # Limit to first 8 languages for speed
                if [[ ${#available_subs[@]} -ge 8 ]]; then
                    break
                fi
            fi
        done <<< "$subs_output"
        
        if [[ ${#available_subs[@]} -gt 0 ]]; then
            AVAILABLE_SUBTITLES=("${available_subs[@]}")
            return 0
        fi
    fi
    
    # No subtitles found
    echo "‚ö†Ô∏è  No subtitles available"
    echo
    return 1
}

# Function to get available formats with simple loading
get_available_formats() {
    local url="$1"
    local formats_file="$TEMP_DIR/formats.txt"
    
    echo "üîç Analyzing available formats..."
    echo -n "üìä Scanning"
    
    # Start background process
    {
        yt-dlp -F "$url" --no-warnings 2>/dev/null > "$formats_file"
        echo $? > "$TEMP_DIR/formats_exit_code"
    } &
    
    local formats_pid=$!
    
    # Simple dot animation
    while kill -0 $formats_pid 2>/dev/null; do
        echo -n "."
        sleep 0.3
    done
    
    # Wait and get exit code
    wait $formats_pid
    local exit_code=$(cat "$TEMP_DIR/formats_exit_code" 2>/dev/null || echo "1")
    
    echo " Done!"
    echo
    
    if [[ "$exit_code" -eq 0 ]]; then
        echo "‚úÖ Quality analysis complete!"
        echo
    else
        echo "‚ùå Failed to analyze available formats"
        return 1
    fi
    
    # Parse video formats
    local video_formats=()
    local format_descriptions=()
    
    # Add audio-only option
    video_formats+=("bestaudio")
    format_descriptions+=("üéµ Audio Only (Best Quality)")
    
    # Parse available video formats
    while IFS= read -r line; do
        if [[ "$line" =~ ^[0-9]+ ]] && [[ "$line" =~ video ]] && [[ ! "$line" =~ "audio only" ]]; then
            local format_id=$(echo "$line" | awk '{print $1}')
            local ext=$(echo "$line" | awk '{print $2}')
            local resolution=$(echo "$line" | awk '{print $3}')
            local fps=$(echo "$line" | grep -o '[0-9]*fps' || echo "")
            local filesize=$(echo "$line" | grep -o '[0-9.]*[MG]iB' || echo "")
            
            # Determine quality emoji and label
            local quality_emoji=""
            local quality_label=""
            
            if [[ "$resolution" =~ "3840x2160" || "$resolution" =~ "2160" ]]; then
                quality_emoji="üèÜ"
                quality_label="4K UHD"
            elif [[ "$resolution" =~ "2560x1440" || "$resolution" =~ "1440" ]]; then
                quality_emoji="üíé"
                quality_label="2K QHD"
            elif [[ "$resolution" =~ "1920x1080" || "$resolution" =~ "1080" ]]; then
                quality_emoji="‚≠ê"
                quality_label="Full HD"
            elif [[ "$resolution" =~ "1280x720" || "$resolution" =~ "720" ]]; then
                quality_emoji="üì∫"
                quality_label="HD"
            elif [[ "$resolution" =~ "480" ]]; then
                quality_emoji="üì±"
                quality_label="SD"
            else
                quality_emoji="üìπ"
                quality_label="$resolution"
            fi
            
            # Build description
            local description="$quality_emoji $quality_label"
            [[ -n "$resolution" ]] && description+=" ($resolution)"
            [[ -n "$ext" ]] && description+=" [$ext]"
            [[ -n "$fps" ]] && description+=" $fps"
            [[ -n "$filesize" ]] && description+=" - $filesize"
            
            video_formats+=("$format_id")
            format_descriptions+=("$description")
        fi
    done < "$formats_file"
    
    # Add best quality option
    video_formats+=("best")
    format_descriptions+=("üöÄ Best Available (Auto-select)")
    
    # Store in global arrays
    AVAILABLE_FORMATS=("${video_formats[@]}")
    FORMAT_DESCRIPTIONS=("${format_descriptions[@]}")
}

# Function to show format options menu
show_format_menu() {
    echo
    print_header "üìã Available Download Options:"
    draw_separator
    
    for i in "${!FORMAT_DESCRIPTIONS[@]}"; do
        local num=$((i + 1))
        echo -e "${WHITE}   $num.${NC} ${FORMAT_DESCRIPTIONS[$i]}"
    done
    
    draw_separator
    echo
}

# Function to get user choice with input validation
get_user_choice() {
    local max_choice=${#AVAILABLE_FORMATS[@]}
    local choice=""
    
    while true; do
        # Clear input buffer
        while read -r -t 0; do
            read -r
        done
        
        echo -n "üéØ Select download option (1-$max_choice): "
        read -r choice
        
        # Check if choice is a number and within range
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $max_choice ]]; then
            SELECTED_FORMAT_INDEX=$((choice - 1))
            break
        else
            echo "   ‚ùå Invalid choice. Please enter a number between 1 and $max_choice."
            echo
        fi
    done
    
    echo
    echo "‚úÖ Selected: ${FORMAT_DESCRIPTIONS[$SELECTED_FORMAT_INDEX]}"
    echo
}

# Function to check available subtitles with simple loading
check_subtitles() {
    local url="$1"
    local subs_file="$TEMP_DIR/subtitles.txt"
    
    echo -n "üìù Checking subtitles"
    
    # Start background process
    {
        yt-dlp --list-subs "$url" --no-warnings 2>/dev/null > "$subs_file"
        echo $? > "$TEMP_DIR/subs_exit_code"
    } &
    
    local subs_pid=$!
    
    # Simple dot animation
    while kill -0 $subs_pid 2>/dev/null; do
        echo -n "."
        sleep 0.4
    done
    
    # Wait and get exit code
    wait $subs_pid
    local exit_code=$(cat "$TEMP_DIR/subs_exit_code" 2>/dev/null || echo "1")
    
    echo " Done!"
    echo
    
    if [[ "$exit_code" -eq 0 ]] && grep -q "Available subtitles" "$subs_file"; then
        echo "‚úÖ Subtitles found!"
        
        # Parse available subtitle languages
        local available_subs=()
        while IFS= read -r line; do
            if [[ "$line" =~ ^[a-z]{2}(-[A-Z]{2})? ]]; then
                local lang_code=$(echo "$line" | awk '{print $1}')
                local lang_name=$(echo "$line" | cut -d' ' -f2- | sed 's/^[[:space:]]*//')
                available_subs+=("$lang_code|$lang_name")
            fi
        done < "$subs_file"
        
        if [[ ${#available_subs[@]} -gt 0 ]]; then
            AVAILABLE_SUBTITLES=("${available_subs[@]}")
            return 0
        fi
    fi
    
    echo "‚ö†Ô∏è  No subtitles available"
    return 1
}

# Function to show subtitle options
show_subtitle_options() {
    echo
    print_header "üìù Subtitle Options:"
    draw_separator
    
    echo -e "${WHITE}   1.${NC} üö´ No subtitles"
    echo -e "${WHITE}   2.${NC} üåç Auto-select (English if available)"
    
    local counter=3
    for sub in "${AVAILABLE_SUBTITLES[@]}"; do
        local lang_code=$(echo "$sub" | cut -d'|' -f1)
        local lang_name=$(echo "$sub" | cut -d'|' -f2)
        echo -e "${WHITE}   $counter.${NC} üî§ $lang_name ($lang_code)"
        ((counter++))
    done
    
    draw_separator
    echo
}

# Function to get subtitle choice
get_subtitle_choice() {
    local max_choice=$((2 + ${#AVAILABLE_SUBTITLES[@]}))
    local choice=""
    
    while true; do
        echo -e "${CYAN}üìù Select subtitle option (1-$max_choice): ${NC}"
        read -r choice
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $max_choice ]]; then
            SELECTED_SUBTITLE_INDEX=$choice
            break
        else
            print_error "   ‚ùå Invalid choice. Please enter a number between 1 and $max_choice."
            echo
        fi
    done
    
    # Set subtitle preference
    case $SELECTED_SUBTITLE_INDEX in
        1)
            SUBTITLE_OPTION="none"
            SUBTITLE_DESC="üö´ No subtitles"
            ;;
        2)
            SUBTITLE_OPTION="auto"
            SUBTITLE_DESC="üåç Auto-select (English if available)"
            ;;
        *)
            local sub_index=$((SELECTED_SUBTITLE_INDEX - 3))
            local selected_sub="${AVAILABLE_SUBTITLES[$sub_index]}"
            local lang_code=$(echo "$selected_sub" | cut -d'|' -f1)
            local lang_name=$(echo "$selected_sub" | cut -d'|' -f2)
            SUBTITLE_OPTION="$lang_code"
            SUBTITLE_DESC="üî§ $lang_name ($lang_code)"
            ;;
    esac
    
    echo
    print_success "‚úÖ Selected: $SUBTITLE_DESC"
    echo
}

# Function to confirm download
confirm_download() {
    local format_desc="${FORMAT_DESCRIPTIONS[$SELECTED_FORMAT_INDEX]}"
    
    echo -e "${YELLOW}üì• Ready to download:${NC}"
    echo -e "${WHITE}   Format: $format_desc${NC}"
    echo -e "${WHITE}   Subtitles: $SUBTITLE_DESC${NC}"
    echo -e "${WHITE}   Destination: $DOWNLOADS_DIR${NC}"
    echo
    
    while true; do
        echo -e "${CYAN}ü§î Proceed with download? (y/n): ${NC}"
        read -n 1 -r answer
        echo
        
        case $answer in
            [Yy]*)
                return 0
                ;;
            [Nn]*)
                return 1
                ;;
            *)
                print_error "   ‚ùå Please answer y (yes) or n (no)."
                ;;
        esac
    done
}

# Function to download video using the proven working method
download_video() {
    local url="$1"
    local format_code="${AVAILABLE_FORMATS[$SELECTED_FORMAT_INDEX]}"
    
    echo "üöÄ Starting download..."
    echo
    
    # Build yt-dlp command using the same pattern as your working command
    local cmd="yt-dlp"
    cmd+=" -f \"$format_code\""
    cmd+=" -o \"$DOWNLOADS_DIR/%(title)s.%(ext)s\""
    cmd+=" --add-metadata"
    cmd+=" --embed-thumbnail"
    cmd+=" --newline"
    cmd+=" --no-warnings"
    
    # Add subtitle options
    case $SUBTITLE_OPTION in
        "none")
            # No subtitles
            ;;
        "auto")
            cmd+=" --write-subs --sub-lang en,en-US,en-GB --skip-unavailable-fragments"
            ;;
        *)
            cmd+=" --write-subs --sub-lang $SUBTITLE_OPTION --skip-unavailable-fragments"
            ;;
    esac
    
    cmd+=" \"$url\""
    
    echo "üîß Command: $cmd"
    echo
    
    echo "üì° Initializing download..."
    echo
    
    # Execute download directly (like your working command)
    if eval "$cmd"; then
        echo
        echo "üéâ Download completed successfully!"
        echo "üìÅ Files saved to: $DOWNLOADS_DIR"
        
        # Show what was downloaded
        if [[ "$SUBTITLE_OPTION" != "none" ]]; then
            echo "üìù Subtitles: $SUBTITLE_DESC"
        fi
        
        echo
    else
        echo
        echo "‚ùå Download failed!"
        echo "   The same command that worked manually should work here too."
        echo "   Try running this command manually:"
        echo "   $cmd"
        echo
        return 1
    fi
}

# Function to get time-based greeting
get_time_greeting() {
    local hour=$(date +%H)
    
    if [[ $hour -ge 5 && $hour -lt 12 ]]; then
        echo "morning"
    elif [[ $hour -ge 12 && $hour -lt 17 ]]; then
        echo "afternoon"
    elif [[ $hour -ge 17 && $hour -lt 21 ]]; then
        echo "evening"
    else
        echo "night"
    fi
}

# Function to ask for another download
ask_continue() {
    echo
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo
    echo "üéØ What would you like to do next?"
    echo
    echo "   1. üîÑ Download another video"
    echo "   2. üö™ Exit application"
    echo
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo
    
    while true; do
        echo -n "üëÜ Please select an option (1-2): "
        read -r choice
        
        case $choice in
            1)
                echo "‚úÖ Great! Let's download another video."
                echo
                return 0
                ;;
            2)
                local username=$(get_username)
                local time_period=$(get_time_greeting)
                echo
                echo "üëã Thank you $username! Have a great $time_period!"
                echo
                return 1
                ;;
            *)
                echo "   ‚ùå Invalid choice. Please enter 1 or 2."
                echo
                ;;
        esac
    done
}

# Function to show goodbye message
show_goodbye() {
    # This function is no longer needed as goodbye is handled in ask_continue
    return 0
}

# Main function
main() {
    # Show welcome screen first
    show_welcome
    
    # Check dependencies after welcome
    check_dependencies
    
    # Main loop
    while true; do
        # Clear any input buffer before asking for URL
        while read -r -t 0; do
            read -r
        done
        
        # Get YouTube URL with validation
        echo -n "üîó Please enter YouTube URL: "
        read -r url
        echo
        
        # Validate URL format first
        if [[ -z "$url" ]]; then
            echo "‚ùå No URL entered. Please try again."
            echo
            continue
        fi
        
        # Check if it looks like a YouTube URL
        if [[ ! "$url" =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
            echo "‚ùå Please enter a valid YouTube URL (youtube.com or youtu.be)"
            echo
            continue
        fi
        
        # Clean the URL (remove extra parameters that might cause issues)
        url=$(echo "$url" | sed 's/&list=.*//' | sed 's/&start_radio=.*//' | sed 's/&t=.*//')
        
        echo "üîó Using URL: $url"
        echo
        
        # Validate URL
        if ! validate_url "$url"; then
            echo "‚ùå Invalid YouTube URL format. Please try again."
            echo
            continue
        fi
        
        # Get video information quickly
        if ! get_video_info_quick "$url"; then
            continue
        fi
        
        # Get available formats quickly
        get_available_formats_quick "$url"
        
        # Show format menu
        show_format_menu
        
        # Get user choice
        get_user_choice
        
        # Check for subtitles quickly
        if check_subtitles_quick "$url"; then
            show_subtitle_options
            get_subtitle_choice
        else
            SUBTITLE_OPTION="none"
            SUBTITLE_DESC="üö´ No subtitles available"
            # No need to show subtitle menu if none are available
        fi
        
        # Confirm download
        if confirm_download; then
            # Download video
            download_video "$url"
        else
            print_warning "‚èπÔ∏è  Download cancelled."
            echo
        fi
        
        # Ask if user wants to continue
        if ! ask_continue; then
            break
        fi
        
        # Clear screen for next iteration
        clear
        show_welcome
    done
}

# Run main function
main "$@"